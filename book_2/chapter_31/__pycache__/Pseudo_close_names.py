"""Псевдо ззакрыттые имена __name

- помогает избежать конфликтов (когда нужно сделать чтобы атрибуты не переопределялись)
"""


class C1:
    def meth1(self):
        self.x = 88  # имя совпадает в 2х классх

    def meth2(self):
        print(self.x)


class C2:
    def metha(self):
        self.x = 99  # имя совпадает в 2х классх

    def methb(self):
        print(self.x)


# Сами по себе оба класса функционируют. Проблема возникнет, если два класса ког­
# да-нибудь смешаются в одном дереве классов:


class C3(C1, C2): ...


inst = C3()
inst.meth1()
inst.meth2()  # тут x = 88

inst.metha()
inst.methb()  # тут x перезаписалься и x = 99

print(
    inst.__dict__
)  # >>> {x: 88} только один атрибт и он перезаписывается т.к. имя в обоих классах совпадает


"""Когда требуется исключить перезаписывание"""


class C1:
    def meth1(self):
        self.__x = 88  # к имени автоматичесски добаляется перфика _С1__X
        # теперь имена разные и не перезапишут друг руга

    def meth2(self):
        print(self.__x)


class C2:
    def metha(self):
        self.__x = 99  # к имени автоматичесски добаляется перфика _С2__X
        # теперь имена разные и не перезапишут друг руга

    def methb(self):
        print(self.__x)


class C3(C1, C2): ...


inst = C3()
inst.meth1()
inst.meth2()  # >>> 88

inst.metha()
inst.methb()  # >>> 99

print(
    inst.__dict__
)  # >>> {'_C1__x': 88, '_C2__x': 99}  оба атрибута сохранились, но неявно поменялось имя
# Гарантирует что атрибут каждого класса будет использован и не перезапишется при наследовании
