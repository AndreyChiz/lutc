class Parent:
    __slots__ = ["c", "d"]


class Child(Parent):
    __slots__ = [
        "a",
        # "__dict__",
    ]


# __slots__ = [] # при добавлении исключится __dict__ и будут использованы
# объединенные слоты всех родительских классов

"""в обоих классах есть __slots__"""

x = Child()


# без проблем присваиваются имена из __slots__
# обоих классов
x.a = 1
x.d = 2
x.c = 3


# но в __slots__ указаны только имена последнего класса
print(
    f"""видно только слоты из текущего класа {x.__slots__=},
а слоты базового класса не указаны,
но разрешены имена из слотов обоих классов
""",
    end="",
)
# print(f"{x.__dict__=}")

print(f"{x.a=}\n{x.d=}\n{x.c=}", sep="\n")


print(
    f"""в dir() видно все разрешенные имена из __slots__ обоих классов {[name for name in dir(x) if not name.startswith("__") and not name.endswith("__")]}
СЛОТЫ ВСЕХ РОЛДИТЕЛЬСКИХ КЛАССОВ ОБЪЕДИНЯЮТСЯ АВТОМАТИЧЕСКИ
__slots__ исключает __dict__ только экземпляра текущего класса в дочернем __dict__ остается
"""
)
